-- --------Практическое задание по теме “Транзакции, переменные, представления” -------------------


-- 1.В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. 
-- Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. Используйте транзакции.

START TRANSACTION;
INSERT INTO sample1.users (SELECT * FROM shop.users WHERE shop.users.id=1);
COMMIT;


-- 2.Создайте представление, которое выводит название name товарной позиции из таблицы products и соответствующее 
-- название каталога name из таблицы catalogs.

-- CREATE VIEW prod AS SELECT products.name AS p_name, catalogs.name AS c_name FROM catalogs
CREATE OR REPLACE VIEW prod AS SELECT products.name AS p_name, catalogs.name AS c_name FROM products
LEFT JOIN catalogs ON products.id = catalogs.id;

SELECT * FROM prod;



-- 3.(по желанию) Пусть имеется таблица с календарным полем created_at. 
-- В ней размещены разряженые календарные записи за август 2018 года '2018-08-01', '2016-08-04', '2018-08-16' и 2018-08-17. 
-- Составьте запрос, который выводит полный список дат за август, выставляя в соседнем поле значение 1, если дата 
-- присутствует в исходном таблице и 0, если она отсутствует.



-- 4.(по желанию) Пусть имеется любая таблица с календарным полем created_at. Создайте запрос, который удаляет устаревшие 
-- записи из таблицы, оставляя только 5 самых свежих записей.





-- --------------Практическое задание по теме “Администрирование MySQL” (эта тема изучается по вашему желанию)-----------------

-- 1.Создайте двух пользователей которые имеют доступ к базе данных shop. 
-- Первому пользователю shop_read должны быть доступны только запросы на чтение данных, 
-- второму пользователю shop — любые операции в пределах базы данных shop.
CREATE USER only_read;
GRANT SELECT ON shop.* TO  'only_read'@'localhost' identified by 'pass';


CREATE USER all_user;
GRANT ALL ON shop.* TO all_user;
GRANT GRANT OPTION ON shop.* TO all_user;



-- 2.(по желанию) Пусть имеется таблица accounts содержащая три столбца id, name, password, содержащие первичный ключ, 
-- имя пользователя и его пароль. Создайте представление username таблицы accounts, предоставляющий доступ к столбца id и name. 
-- Создайте пользователя user_read, который бы не имел доступа к таблице accounts, однако, мог бы извлекать записи из представления username.







-- --------------Практическое задание по теме “Хранимые процедуры и функции, триггеры"----------------------------------

-- 1.Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток. 
-- С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", с 12:00 до 18:00 функция должна возвращать фразу "Добрый день", 
-- с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи".

 -- Выдает ошибку, не понимаю в чем она
delimiter // 
DROP FUNCTION IF EXISTS hello
CREATE FUNCTION hello() 
	BEGIN 
		RETURN CASE 
 			WHEN CURTIME() BETWEEN '06:00:00' AND  '11:59:59' THEN 'Доброе утро'
 			WHEN CURTIME() BETWEEN '12:00:00' AND '17:59:59' THEN 'Добрый день'
			WHEN CURTIME() BETWEEN '18:00:00' AND '23:59:59' THEN 'Добрый вечер'
			WHEN CURTIME() BETWEEN '00:00:00' AND '05:59:59' THEN 'Доброй ночи'
		END;
	END //
delimiter;


-- 2.В таблице products есть два текстовых поля: name с названием товара и description с его описанием. 
-- Допустимо присутствие обоих полей или одно из них. Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема. 
-- Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были заполнены. 
-- При попытке присвоить полям NULL-значение необходимо отменить операцию.

-- по видеоуроку вообще не поняла что такое триггеры. Поискала в инете инфу, на этом сайте вроде как более менее понятно объяснено https://codetown.ru/sql/triggery/,
-- но как применить это  нашим таблицам не понимаю 


-- 3.(по желанию) Напишите хранимую функцию для вычисления произвольного числа Фибоначчи. 
-- Числами Фибоначчи называется последовательность в которой число равно сумме двух предыдущих чисел. 
-- Вызов функции FIBONACCI(10) должен возвращать число 55.
